You are a Senior Full-Stack Engineer + Data Scientist + Software Architect.

You will build a production-grade Dynamic Pricing Tool for Car Rental integrated into an existing SaaS called Renty.

This is NOT a demo.
This is a real product running on real SQL Server data (historical data exists up to 18-Nov-2025, and may include earlier years too).

No simulated data. No placeholders. No fake results.
No assumptions ‚Äî if something is ambiguous, STOP and ask me.

We will build in strict chunks, and each chunk must be validated 100% using real data before moving forward.

‚úÖ REPO & TARGET DEPLOYMENT

Use repo: https://github.com/Samer-Is/rpiv4

Repo is empty ‚Üí scaffold full solution

Deployment target: Windows Server

Must be Docker-ready

Must include clear README for deployment steps

0) NON-NEGOTIABLE RULES (STRICT)
0.1 Data rules

Use real SQL Server data only

No demo data ever

If you can‚Äôt find required data, you must investigate properly (joins / filters / dictionary)

0.2 Multi-tenancy rules (SaaS-grade)

This tool must be built as multi-tenant, because it will integrate with Renty SaaS.

‚úÖ Best practice required:

Use a shared table design with a tenant_id column everywhere (row-level tenancy)

Tenant context must come from:

JWT claims OR request header (you choose best simple approach)

MVP tenant is YELO only, but architecture must remain multi-tenant

0.3 No over-engineering

Code must be:

human readable

easy to debug

clean and simple

consistent structure and naming

Even deep learning must be implemented in a clean, readable way.

1) SOURCE DATA (SQL SERVER)

SQL Server contains 2 databases on same instance:

eJarDbSTGLite

eJarDbReports

We will use only real tables found in these databases.

Core tables you mentioned (must use exact schema.table names from DB dictionary):

From eJarDbSTGLite:

rental.contracts (or rental.contract ‚Üí confirm exact name)

rental.bookings

rental.rentalrates

rental.ContractsPaymentsItemsDetails

fleet.vehicles

fleet.CarCategories

fleet.CarModels

rental.lookups

üìå IMPORTANT:

There are DB dictionary .txt files in the repo working directory

You MUST read ALL dictionary files first and extract:

keys

joins

meaning of columns

tenant_id location

branch_id mapping

category mapping

‚Äúfinal base price paid‚Äù column(s)

No guessing.

2) DATABASE DESIGN (BEST PRACTICE FOR SAAS)

We must not pollute the source tables (rental/fleet).
We will create a dedicated application database to store metadata + engineered facts.

‚úÖ Preferred approach:

Create a new database: RentyDynamicPricing (or similar)

It contains two schemas:

appconfig ‚Üí configuration tables (tenants, settings, guardrails, weights, mappings, approvals)

dynamicpricing ‚Üí feature store + forecasts + recommendations history

If creating a new DB is not allowed, fallback:

Create schemas inside eJarDbSTGLite:

appconfig

dynamicpricing

BUT you MUST ask me before finalizing which approach we will use.

‚úÖ Every table in app DB must include:

tenant_id

created_at

updated_at

optionally created_by

3) PRODUCT BEHAVIOR (DYNAMIC PRICING LOGIC)

Dynamic pricing depends on 5 elements, all configurable in UI:

Current utilization from future bookings

Actual utilization from active contracts (executed utilization)

Demand forecast model (30-day horizon)

Weather + seasonality + holidays + events (from web APIs, described below)

Competitor pricing (Booking.com API)

Granularity

All calculations and recommendations are at:
‚úÖ Branch √ó Category √ó Date

Not all categories move same direction:

economy can go premium

luxury can discount

4) UI RULES (STRICT)
Branch selection

Only dropdown allowed is Branch

UI must show 6 categories in ONE page at the same time

No category dropdown

No toggles for category selection

Output per category (must show)

Each category card shows:

LEFT (Base Prices)

Daily base

Weekly base

Monthly base

RIGHT (Recommended Prices)

Daily recommended

Weekly recommended

Monthly recommended

Also show:

Premium / Discount % clearly highlighted

Actions (per category):

Approve button

Skip button

Window

Must support selecting start_date

Must show 30-day rolling window recommendations:

day 1 ‚Üí day 30

Approvals apply to the selected window results (and are logged)

Guardrails (Configurable)

Min price

Min discount %

Max discount %
System must block approving prices outside guardrails.

5) IMPORTANT: UTILIZATION LOGIC (CONFIGURABLE IN UI)

Utilization must be configurable because each tenant defines availability differently.

Default utilization formula (per category per date)

Numerator includes:

Active contracts overlapping date

Future bookings overlapping date

Denominator includes:

Total fleet available for rent

EXCLUDING sold/out-of-service/etc.

Statuses come from:

vehicle history tables / lookups (discover via dictionary)

UI Admin must configure:

statuses included in denominator (available)

statuses included in numerator (occupied)

excluded statuses

Must validate utilization ‚àà [0,1].

6) TOP SELECTION SCOPE (INITIAL MVP)

We will start with a limited scope:

‚úÖ Top 6 branches

3 airport

3 non-airport
Definition: highest executed rentals volume

‚úÖ Top 6 categories
Definition: highest executed rentals volume

Admin must be able to override selection later.

7) DEMAND FORECASTING ‚Äî BEST PRACTICE + MULTI MODEL
7.1 MUST be scalable multi-tenant forecasting

DO NOT train a separate model for every branch√ócategory (not scalable for SaaS).

‚úÖ Best practice approach:
Train a GLOBAL forecasting model that learns across:

tenant_id

branch_id

category_id

time features

lag features

external signals

Then forecast demand for any series using the same model.

This prevents having ‚Äúhundreds of models‚Äù.

7.2 Forecast horizon + rolling window

Forecast horizon is 30 days

Output must generate daily demand forecast for day+1..day+30

7.3 Training data time rule

You must follow this rule:

Demand forecasting training uses 2023+ only
But also keep capability to backfill earlier if I approve later.

Validation period:

You must detect available min/max dates in the DB and propose final split.

7.4 Multi-model requirement (MANDATORY)

You MUST implement an evaluation pipeline that tries multiple models, including deep learning:

Baseline models (must include):

Seasonal Naive

ETS (Exponential Smoothing)

Classical (try if helpful):

SARIMAX (keep simple)

Machine learning global model (recommended):

LightGBM or XGBoost regression with lag features

Deep learning (mandatory attempt, GPU):

PyTorch LSTM model for global forecasting
(simple architecture, readable training loop, uses CUDA if available)

‚úÖ Model selection rule:

Backtest models using rolling-origin evaluation

Compute MAE + MAPE (+ sMAPE if you want)

Compare all models

Choose best model globally OR best per tenant (simple rule)

Store chosen model name + metrics in DB

Do not overcomplicate model orchestration: keep it readable.

8) WEATHER + HOLIDAYS + EVENTS (NEW FINAL VERSION)

Ignore the old weather/events keys and old weather prompt section.
Use ONLY the following approach:

8.1 Weather data (mandatory)

Source: https://open-meteo.com/

Training dataset MUST include these engineered features:

t_mean_next_24h

t_max_next_24h

wind_mean_next_24h

visibility_min_next_24h

bad_weather_score (0/1 or 0‚Äì1)

extreme_heat_flag (1 if max temp > 43C else 0)

Implementation must support:

historical mode (training)

production mode (future window)

Branch‚ÜíCity mapping:

DB has no lat/lon, so create an admin-configurable mapping table:

branch_id ‚Üí city_name

city_name ‚Üí lat/lon

8.2 KSA calendar + events pipeline (mandatory)

Build a Python pipeline called:
‚úÖ ksa_calendar_pipeline

GOAL: create TWO SQL tables:

ksa_holidays (historical + future SA public holidays)

ksa_daily_event_signal (daily intensity per city via GDELT)

Requirements

Python 3.10+

Use requests + pandas + pyodbc only

Runs locally, no cloud deps

Supports:
A) Backfill mode: last N years
B) Daily mode:

holidays: today + next 365 days

events: today only

Holidays source: Calendarific API

env var: CALENDARIFIC_API_KEY

country: SA

Events source: GDELT 2.1 DOC API (no key)
Cities:

Riyadh

Jeddah

Dammam

Store per city/date:

gdelt_volume

gdelt_score = log(1 + volume)

SQL connection env vars:

SQL_SERVER

SQL_DATABASE

SQL_USERNAME

SQL_PASSWORD

Folder structure (exact):
ksa_calendar_pipeline/
config.py
db.py
holidays_calendarific.py
events_gdelt.py
backfill.py
run_daily.py
feature_builder.py
README.md

Functions (exact):
holidays_calendarific.py:

fetch_holidays(year) -> dataframe(date, holiday_name, holiday_type)

events_gdelt.py:

fetch_gdelt_score(city, date) -> volume, score

db.py:

create_tables_if_not_exist()

upsert_holidays(df)

upsert_event_signal(df)

backfill.py:

backfill_holidays(start_year, end_year)

backfill_events(start_date, end_date)

run_daily.py:

update_holidays(today, horizon_days=365)

update_events(today for each city)

feature_builder.py:

build_features(date, city) -> is_holiday, holiday_name, event_score_today, event_score_3d_avg, event_score_7d_avg

Must include:

simple logging

robust retry loops for APIs

no hardcoded secrets

clean readable code

9) COMPETITOR PRICING (BOOKING.COM API)

Competitor prices come from Booking.com API.

You MUST read local file in repo:

booking_com_api (in repo root)

Use it for:

base URL

endpoints

auth

sample responses

mapping logic

Competitor index rule:

match competitor products to our categories

compute competitor price as:
‚úÖ average of top 3 competitors (not lowest)

Add admin mapping config:

internal category ‚Üí competitor product mapping

Include caching to avoid rate limits.

10) DYNAMIC PRICING ENGINE (FINAL RECOMMENDATION OUTPUT)

For each tenant_id + branch_id + start_date:
Return recommended prices for:

6 categories

30-day horizon

Inputs:

base rates (daily/weekly/monthly)

utilization (contracts+bookings)

demand forecast (30 days)

competitor index

weather + holiday + event signals

All 5 elements must be weighted:

weights configurable in UI per tenant

Guardrails enforced:

min price

min discount %

max discount %

Output fields per day:

base daily/weekly/monthly

recommended daily/weekly/monthly

premium/discount %

Explainability:

NO LLM required

deterministic explanation summary like:
‚ÄúHigh utilization + high forecast demand increased price, competitor index reduced it, adjusted within guardrails.‚Äù

Store:

recommendations history

model version used

explanation

approval/skip logs

11) BACKEND + FRONTEND STACK (PRODUCTION)

Backend:

FastAPI (Python)

SQLAlchemy + pyodbc

Pydantic

Alembic migrations (for appconfig + dynamicpricing schemas)

Frontend:

React + TypeScript

Use ShadCN + Tailwind (choose one and stay consistent)

Auth:

Simple JWT auth

Tenant awareness from token (tenant_id claim)

Background execution:

If needed: a very simple scheduled runner (cron-style container or Windows Task Scheduler)

Forecast + recommendation refresh can run daily

12) REQUIRED API ENDPOINTS

Health

GET /health

Auth

POST /auth/login

Config

GET /config/weights

POST /config/weights

GET /config/utilization

POST /config/utilization

GET /config/guardrails

POST /config/guardrails

GET /config/branch-city

POST /config/branch-city

GET /config/competitor-mapping

POST /config/competitor-mapping

Selection (top branches/categories + override)

GET /config/selection

POST /config/selection

Recommendations

GET /recommendations?branch_id=...&start_date=...

Approvals

POST /recommendations/{id}/approve

POST /recommendations/{id}/skip

13) FEATURE STORE TABLES (DO NOT CREATE PER SERIES TABLES)

Do NOT create branch√ócategory separate tables.

Create clean shared tables:

dynamicpricing.fact_daily_demand

Contains per day per branch per category:

tenant_id

demand_date

branch_id

category_id

executed_rentals_count (target)

avg_base_price_paid

utilization_contracts

utilization_bookings

weather features

holiday/event features

split_flag (TRAIN / VALIDATION)

dynamicpricing.forecast_demand_30d

tenant_id

run_date

branch_id

category_id

forecast_date

horizon_day (1..30)

forecast_demand

model_name

model_version

created_at

dynamicpricing.recommendations_30d

tenant_id

run_date

branch_id

category_id

forecast_date

base_daily/base_weekly/base_monthly

rec_daily/rec_weekly/rec_monthly

premium_discount_pct

explanation_text

status (PENDING/APPROVED/SKIPPED)

created_at

appconfig tables (must exist)

appconfig.tenants

appconfig.tenant_settings

appconfig.signal_weights

appconfig.guardrails

appconfig.utilization_status_config

appconfig.branch_city_mapping

appconfig.competitor_mapping

appconfig.selection_config

appconfig.audit_log

All tables must include tenant_id + timestamps.

14) BUILD PLAN ‚Äî MUST BE DONE IN CHUNKS + VALIDATION

You must implement phases strictly.
Do not proceed until validations pass and are documented.

‚úÖ CHUNK 0 ‚Äî Project Scaffold
Deliverables:
Monorepo structure:

rpiv4/
backend/
app/
main.py
core/
db/
models/
schemas/
services/
routers/
utils/
tests/
alembic/
requirements.txt
Dockerfile
frontend/
src/
pages/
components/
api/
styles/
package.json
Dockerfile
docker-compose.yml
README.md
docs/
requirements.md
architecture.md
validation_checklist.md
decisions_log.md

Validation:

backend runs GET /health

frontend runs login page + skeleton dashboard

STOP and ask me for SQL Server connection details.

‚úÖ CHUNK 1 ‚Äî SQL Server Connection + Data Discovery (REAL DATA)
Goals:

connect to SQL Server

discover:

tenant_id dimension location

branch mapping

category mapping

executed rentals definition

individual rental filtering (exclude corporate/lease/etc.)

base price extraction from ContractsPaymentsItemsDetails

min/max dates per table

Deliverables:

docs/data_discovery_report.md

row counts per major table (YELO tenant)

min/max dates per table

join paths diagram

backend/app/services/data_exploration.py

Validation:

show total contracts count for YELO

show total bookings count for YELO

confirm date ranges include data through 18-Nov-2025

confirm individual rentals filter returns non-zero

confirm base price extraction works for at least 1 branch+category

STOP if:

tenant_id ambiguous

branch/category mapping ambiguous

base price ambiguous

date inconsistencies found

‚úÖ CHUNK 2 ‚Äî App DB + Schemas + Config Tables
Goals:

create appconfig + dynamicpricing schemas

create all metadata tables + migrations

Validation:

tables exist

tenant record exists (YELO)

configs can be written/read via API

‚úÖ CHUNK 3 ‚Äî Base Price Engine
Goals:

build BaseRateService returning daily/weekly/monthly base prices

based on final price paid logic

Validation:

verify prices exist for 5 random cases

validate effective period logic (if exists)

‚úÖ CHUNK 4 ‚Äî Utilization Engine (Configurable)
Goals:

compute utilization per branch√ócategory√ódate using config statuses

build admin UI to edit statuses

Validation:

utilization ‚àà [0,1]

differs across categories

validate via SQL vs python aggregation

‚úÖ CHUNK 5 ‚Äî External Signals
Goals:

Open-Meteo weather service + storage table

ksa_calendar_pipeline implemented and populates tables

branch‚Üícity mapping config page

Validation:

weather table non-empty

holiday table populated

gdelt signal table populated

feature_builder returns correct outputs

‚úÖ CHUNK 6 ‚Äî Feature Store Builder
Goals:

build dynamicpricing.fact_daily_demand

fill for YELO top branches/categories

include TRAIN/VALIDATION split

Validation:

counts and date ranges correct

target not flatline

missing rate small and documented

‚úÖ CHUNK 7 ‚Äî Forecasting Multi-Model Trainer (GLOBAL + GPU)
Goals:

implement multi-model training/backtesting

include LSTM GPU attempt

store best model + metrics

generate 30-day forecasts into forecast table

Validation:

metrics vs naive baseline

forecasts not flatline

correct shape: horizon 30 days

‚úÖ CHUNK 8 ‚Äî Competitor Pricing Integration
Goals:

Booking.com API integration + mapping config

competitor index = avg top 3

caching

Validation:

API works with real response

mapping works for at least 2 categories

‚úÖ CHUNK 9 ‚Äî Pricing Engine (Final Recommendation)
Goals:

combine signals with weights

enforce guardrails

store recommendations and explanation

Validation:

end-to-end output for one branch

premium/discount not identical across categories

guardrails enforced at approval

‚úÖ CHUNK 10 ‚Äî Frontend Dashboard
Goals:

Branch dropdown only

Start date selector

Show 6 categories at once

show base vs recommended daily/weekly/monthly

show 30-day window (table/scroll)

approve/skip per category

Validation:

approve/skip updates DB audit log

no broken states

loads real data

‚úÖ CHUNK 11 ‚Äî Deployment
Goals:

docker-compose

env example

Windows Server instructions

Validation:

system runs fully in containers

15) OUTPUT FORMAT AFTER EACH CHUNK (MANDATORY)

After each chunk you must output:

What files were created/changed

What validations were run

What real results were observed (counts, dates, samples)

Status: DONE ‚úÖ or BLOCKED ‚ùå

Next chunk plan

16) REQUIRED QUESTIONS (ASK ME NOW BEFORE CHUNK 1)

Before coding CHUNK 1, ask me:

SQL Server connection details:

server/host

instance name

Windows auth vs SQL auth

username/password if SQL auth

port

Confirm which database to create app tables in:

new DB RentyDynamicPricing OR schemas inside eJarDbSTGLite

Confirm the ‚Äútoday‚Äù logic:

do we simulate today as 31-May-2026?

or another date?

Confirm demand training min date:

strictly 2023+ (recommended)

or allow 2022+ (if needed)

Confirm MVP selection:

top 6 branches (3 airport + 3 non-airport)

confirm top 6 categories or 6 car models eg hyundai accent?

DO NOT PROCEED until I answer.

‚úÖ Start now with CHUNK 0 scaffold.
Then STOP and ask me the questions above before CHUNK 1.