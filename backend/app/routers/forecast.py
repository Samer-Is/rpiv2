"""
Forecast API Router - CHUNK 7
Endpoints for training models and getting forecasts
"""
from datetime import date
from typing import Optional, List
from fastapi import APIRouter, Depends, HTTPException, Query, BackgroundTasks
from sqlalchemy.orm import Session
from sqlalchemy import text
from pydantic import BaseModel

from ..database import get_app_db

router = APIRouter(prefix="/forecast", tags=["Forecasting"])


class TrainingRequest(BaseModel):
    """Request to trigger model training."""
    tenant_id: int = 1


class TrainingResponse(BaseModel):
    """Response from model training."""
    tenant_id: int
    train_samples: int
    validation_samples: int
    models_trained: List[str]
    best_model: str
    forecasts_generated: int


class ForecastRecord(BaseModel):
    """Single forecast record."""
    forecast_date: date
    horizon_day: int
    forecast_demand: float
    model_name: str


class ForecastResponse(BaseModel):
    """Response containing forecasts."""
    tenant_id: int
    branch_id: int
    category_id: int
    run_date: date
    forecasts: List[ForecastRecord]


class ModelMetricsResponse(BaseModel):
    """Model evaluation metrics."""
    model_name: str
    mae: float
    mape: Optional[float] = None
    rmse: Optional[float] = None
    is_best_model: bool
    training_time_sec: Optional[float] = None


@router.post("/train", response_model=TrainingResponse)
def train_models(
    request: TrainingRequest,
    db: Session = Depends(get_app_db)
):
    """
    Train all forecasting models and select the best one.
    
    This operation:
    1. Loads training and validation data from feature store
    2. Trains multiple models (Naive, ETS, LightGBM, LSTM)
    3. Backtests models on validation data
    4. Selects best model based on MAE
    5. Generates 30-day forecasts
    6. Saves forecasts and metrics to database
    
    **Warning**: This may take several minutes depending on data size.
    """
    from ..ml.trainer import ForecastTrainingService
    
    try:
        service = ForecastTrainingService(db)
        result = service.run_full_pipeline(tenant_id=request.tenant_id)
        
        return TrainingResponse(
            tenant_id=result["tenant_id"],
            train_samples=result["train_samples"],
            validation_samples=result["validation_samples"],
            models_trained=result["models_trained"],
            best_model=result["best_model"],
            forecasts_generated=result["forecasts_generated"]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Training failed: {str(e)}")


@router.get("/forecasts", response_model=ForecastResponse)
def get_forecasts(
    branch_id: int = Query(..., description="Branch ID"),
    category_id: int = Query(..., description="Category ID"),
    tenant_id: int = Query(default=1, description="Tenant ID"),
    run_date: Optional[date] = Query(default=None, description="Forecast run date (defaults to latest)"),
    db: Session = Depends(get_app_db)
):
    """
    Get 30-day demand forecasts for a specific branch and category.
    
    Returns forecasts generated by the best selected model.
    """
    # Get latest run_date if not specified
    if run_date is None:
        result = db.execute(text("""
            SELECT MAX(run_date) FROM dynamicpricing.forecast_demand_30d
            WHERE tenant_id = :tenant_id
        """), {"tenant_id": tenant_id})
        run_date = result.scalar()
        
        if run_date is None:
            raise HTTPException(status_code=404, detail="No forecasts found. Run training first.")
    
    # Get forecasts
    result = db.execute(text("""
        SELECT forecast_date, horizon_day, forecast_demand, model_name
        FROM dynamicpricing.forecast_demand_30d
        WHERE tenant_id = :tenant_id
          AND branch_id = :branch_id
          AND category_id = :category_id
          AND run_date = :run_date
        ORDER BY horizon_day
    """), {
        "tenant_id": tenant_id,
        "branch_id": branch_id,
        "category_id": category_id,
        "run_date": run_date
    })
    
    rows = result.fetchall()
    if not rows:
        raise HTTPException(status_code=404, detail="No forecasts found for this combination")
    
    forecasts = [
        ForecastRecord(
            forecast_date=row[0],
            horizon_day=row[1],
            forecast_demand=float(row[2]),
            model_name=row[3]
        )
        for row in rows
    ]
    
    return ForecastResponse(
        tenant_id=tenant_id,
        branch_id=branch_id,
        category_id=category_id,
        run_date=run_date,
        forecasts=forecasts
    )


@router.get("/metrics", response_model=List[ModelMetricsResponse])
def get_model_metrics(
    tenant_id: int = Query(default=1, description="Tenant ID"),
    evaluation_date: Optional[date] = Query(default=None, description="Evaluation date (defaults to latest)"),
    db: Session = Depends(get_app_db)
):
    """
    Get evaluation metrics for all trained models.
    
    Returns MAE, MAPE, RMSE and other metrics from the latest evaluation.
    """
    # Get latest evaluation date if not specified
    if evaluation_date is None:
        result = db.execute(text("""
            SELECT MAX(evaluation_date) FROM dynamicpricing.model_evaluation_metrics
            WHERE tenant_id = :tenant_id
        """), {"tenant_id": tenant_id})
        evaluation_date = result.scalar()
        
        if evaluation_date is None:
            raise HTTPException(status_code=404, detail="No metrics found. Run training first.")
    
    # Get metrics
    result = db.execute(text("""
        SELECT model_name, mae, mape, rmse, is_best_model, training_time_sec
        FROM dynamicpricing.model_evaluation_metrics
        WHERE tenant_id = :tenant_id AND evaluation_date = :eval_date
        ORDER BY mae
    """), {"tenant_id": tenant_id, "eval_date": evaluation_date})
    
    rows = result.fetchall()
    
    return [
        ModelMetricsResponse(
            model_name=row[0],
            mae=float(row[1]),
            mape=float(row[2]) if row[2] else None,
            rmse=float(row[3]) if row[3] else None,
            is_best_model=bool(row[4]),
            training_time_sec=float(row[5]) if row[5] else None
        )
        for row in rows
    ]


@router.get("/best-model")
def get_best_model(
    tenant_id: int = Query(default=1, description="Tenant ID"),
    db: Session = Depends(get_app_db)
):
    """Get the currently selected best model for a tenant."""
    result = db.execute(text("""
        SELECT TOP 1 selected_model, selection_metric, metric_value, selection_date
        FROM dynamicpricing.best_model_selection
        WHERE tenant_id = :tenant_id
        ORDER BY selection_date DESC
    """), {"tenant_id": tenant_id})
    
    row = result.fetchone()
    if not row:
        raise HTTPException(status_code=404, detail="No best model selected. Run training first.")
    
    return {
        "tenant_id": tenant_id,
        "selected_model": row[0],
        "selection_metric": row[1],
        "metric_value": float(row[2]),
        "selection_date": row[3]
    }


@router.get("/summary")
def get_forecast_summary(
    tenant_id: int = Query(default=1, description="Tenant ID"),
    db: Session = Depends(get_app_db)
):
    """Get summary statistics about forecasts."""
    # Get latest run info
    result = db.execute(text("""
        SELECT 
            MAX(run_date) as last_run,
            COUNT(DISTINCT branch_id) as branches,
            COUNT(DISTINCT category_id) as categories,
            COUNT(*) as total_forecasts,
            MIN(forecast_date) as forecast_start,
            MAX(forecast_date) as forecast_end,
            AVG(forecast_demand) as avg_demand,
            MAX(model_name) as model_used
        FROM dynamicpricing.forecast_demand_30d
        WHERE tenant_id = :tenant_id
    """), {"tenant_id": tenant_id})
    
    row = result.fetchone()
    
    if row[0] is None:
        return {"message": "No forecasts available. Run training first."}
    
    return {
        "tenant_id": tenant_id,
        "last_run_date": row[0],
        "branches_count": row[1],
        "categories_count": row[2],
        "total_forecasts": row[3],
        "forecast_range": {
            "start": row[4],
            "end": row[5]
        },
        "average_demand": float(row[6]) if row[6] else 0,
        "model_used": row[7]
    }
